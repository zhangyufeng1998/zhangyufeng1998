const l=JSON.parse('{"key":"v-376d227c","path":"/posts/rust/rust%E5%85%A5%E9%97%A8/18-.html","title":"18.模式匹配","lang":"zh-CN","frontmatter":{"title":"18.模式匹配","date":"2023-05-26T00:00:00.000Z","icon":"rust","category":"rust","description":"模式 模式是Rust中的一种特殊语法，用于匹配复杂和简单类型的结构 将模式与匹配表达式和其他构造结合使用，可以更好地控制程序的控制流 模式由以下元素（的一些组合）组成： 字面值 结构的数据、enum、struct和tuple 变量 通配符 占位符 想要使用模式，需要将其与某个值进行比较 如果模式匹配，就可以在代码中使用这个值的相应部分","head":[["meta",{"property":"og:url","content":"https://zhangyufeng19988.github.io/zyf/posts/rust/rust%E5%85%A5%E9%97%A8/18-.html"}],["meta",{"property":"og:title","content":"18.模式匹配"}],["meta",{"property":"og:description","content":"模式 模式是Rust中的一种特殊语法，用于匹配复杂和简单类型的结构 将模式与匹配表达式和其他构造结合使用，可以更好地控制程序的控制流 模式由以下元素（的一些组合）组成： 字面值 结构的数据、enum、struct和tuple 变量 通配符 占位符 想要使用模式，需要将其与某个值进行比较 如果模式匹配，就可以在代码中使用这个值的相应部分"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"ZYF"}],["meta",{"property":"article:published_time","content":"2023-05-26T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"18.模式匹配\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-05-26T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ZYF\\",\\"url\\":\\"https://zhangyufeng19989.github.io\\",\\"email\\":\\"907392790@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"模式","slug":"模式","link":"#模式","children":[]},{"level":2,"title":"18.1 用到模式的地方","slug":"_18-1-用到模式的地方","link":"#_18-1-用到模式的地方","children":[{"level":3,"title":"match的Arm","slug":"match的arm","link":"#match的arm","children":[]},{"level":3,"title":"条件if let 表达式","slug":"条件if-let-表达式","link":"#条件if-let-表达式","children":[]},{"level":3,"title":"while let 条件循环","slug":"while-let-条件循环","link":"#while-let-条件循环","children":[]},{"level":3,"title":"for循环","slug":"for循环","link":"#for循环","children":[]},{"level":3,"title":"let语句","slug":"let语句","link":"#let语句","children":[]},{"level":3,"title":"函数的参数","slug":"函数的参数","link":"#函数的参数","children":[]}]},{"level":2,"title":"18.2 可辨驳性：模式是否会无法匹配","slug":"_18-2-可辨驳性-模式是否会无法匹配","link":"#_18-2-可辨驳性-模式是否会无法匹配","children":[]},{"level":2,"title":"18.3 模式匹配的语法","slug":"_18-3-模式匹配的语法","link":"#_18-3-模式匹配的语法","children":[{"level":3,"title":"匹配字面值","slug":"匹配字面值","link":"#匹配字面值","children":[]},{"level":3,"title":"匹配命名变量","slug":"匹配命名变量","link":"#匹配命名变量","children":[]},{"level":3,"title":"多重模式","slug":"多重模式","link":"#多重模式","children":[]},{"level":3,"title":"使用 ..= 来匹配某个值的范围的值","slug":"使用-来匹配某个值的范围的值","link":"#使用-来匹配某个值的范围的值","children":[]},{"level":3,"title":"结构以分解值","slug":"结构以分解值","link":"#结构以分解值","children":[]},{"level":3,"title":"解构enum","slug":"解构enum","link":"#解构enum","children":[]},{"level":3,"title":"解构嵌套的struct和enum","slug":"解构嵌套的struct和enum","link":"#解构嵌套的struct和enum","children":[]},{"level":3,"title":"结构struct和tuples","slug":"结构struct和tuples","link":"#结构struct和tuples","children":[]},{"level":3,"title":"使用_来忽略整个值","slug":"使用-来忽略整个值","link":"#使用-来忽略整个值","children":[]},{"level":3,"title":"使用嵌套的_来忽略值的一部分","slug":"使用嵌套的-来忽略值的一部分","link":"#使用嵌套的-来忽略值的一部分","children":[]},{"level":3,"title":"通过使用_开头命名来忽略未使用的变量","slug":"通过使用-开头命名来忽略未使用的变量","link":"#通过使用-开头命名来忽略未使用的变量","children":[]},{"level":3,"title":"使用..来忽略值的剩余部分","slug":"使用-来忽略值的剩余部分","link":"#使用-来忽略值的剩余部分","children":[]},{"level":3,"title":"使用match守卫来提供额外的条件","slug":"使用match守卫来提供额外的条件","link":"#使用match守卫来提供额外的条件","children":[]},{"level":3,"title":"@绑定","slug":"绑定","link":"#绑定","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.46,"words":1639},"filePathRelative":"posts/rust/rust入门/18-.md","localizedDate":"2023年5月26日","excerpt":"<h2> 模式</h2>\\n<ul>\\n<li>模式是Rust中的一种特殊语法，用于匹配复杂和简单类型的结构</li>\\n<li>将模式与匹配表达式和其他构造结合使用，可以更好地控制程序的控制流</li>\\n<li>模式由以下元素（的一些组合）组成：\\n<ul>\\n<li>字面值</li>\\n<li>结构的数据、enum、struct和tuple</li>\\n<li>变量</li>\\n<li>通配符</li>\\n<li>占位符</li>\\n</ul>\\n</li>\\n<li>想要使用模式，需要将其与某个值进行比较\\n<ul>\\n<li>如果模式匹配，就可以在代码中使用这个值的相应部分</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{l as data};
