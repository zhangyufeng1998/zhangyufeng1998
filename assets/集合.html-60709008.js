import{_ as a,X as s,Y as l,a2 as n}from"./framework-a8949fcd.js";const i={},e=n(`<h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合" aria-hidden="true">#</a> 集合</h2><h3 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h3><ul><li><p>ArrayList的扩容规则</p></li><li><p>Iterator的fail-fast、fail-safe机制</p></li></ul><h4 id="扩容机制" tabindex="-1"><a class="header-anchor" href="#扩容机制" aria-hidden="true">#</a> 扩容机制</h4><p>无参构造容量是0，如果传入的是一个集合，容量就是集合的大小；</p><p>首次扩容，容量增加到10，新数组替换掉旧的数组（0-&gt;10）</p><p>以后扩容会扩容到原来容量的1.5倍（底层用移位运算，右移1位再加上原始容量），将旧数组的元素拷贝的新数组上</p><p>上面是add方法；addAll添加的是collection集合，扩容是选择下次扩容（正常情况下）和实际元素个数的较大值。</p><ul><li><code>ArrayList()</code>会使用长度为0的数组</li><li><code>ArrayList(int initialCapacity)</code>会使用指定容量的数组</li><li><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>会使用c的大小作为数组容量</li><li><code>add(Object o)</code>首次扩容为10，再次扩容为上次容量的1.5倍</li><li><code>addAll(Collection c)</code>没有元素时，扩容为Math.max(10,实际元素个数)，有元素时为<code>Math.max(原容量1.5倍，实际元素个数)</code></li></ul><h4 id="iterator的fail-fast、fail-safe" tabindex="-1"><a class="header-anchor" href="#iterator的fail-fast、fail-safe" aria-hidden="true">#</a> Iterator的fail-fast、fail-safe</h4><ul><li><p><code>fail-fast</code>的典型代表 <code>ArrayList</code>一旦发现遍历的同时其他人来修改，则立即抛异常</p><ul><li>维护一个迭代开始的修改次数的成员变量，如果不相等则抛出异常</li></ul></li><li><p><code>fail-safe</code>的典型代表 <code>CopyOnWriteArrayList</code> 发现遍历的同时其他人来修改，应当能有应对策略，例如牺牲一致性来让整个遍历运行完成</p><ul><li>添加是一个数组，遍历是另一个数组，读写分离</li></ul></li></ul><h3 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist" aria-hidden="true">#</a> LinkedList</h3><h4 id="arraylist对比linkedlist" tabindex="-1"><a class="header-anchor" href="#arraylist对比linkedlist" aria-hidden="true">#</a> ArrayList对比LinkedList</h4><ul><li><p><code>ArrayList</code></p><ul><li><p>基于数组，需要连续内存</p></li><li><p>随机访问快（根据下表访问）</p></li><li><p>尾部插入、删除性能可以，其他部分插入、删除都会移动数据，因此性能较低</p></li><li><p>可以利用cpu缓存，局部性原理</p></li><li><p>实现了<code>RandomAccess</code>接口</p></li></ul></li><li><p><code>LinkedList</code></p><ul><li><p>基于双向链表，无需连续内存</p></li><li><p>随机访问慢（需要沿着链表遍历）</p></li><li><p>头部插入删除性能高</p></li><li><p>占用内存多</p></li></ul></li></ul><h3 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h3><p>a -&gt; 计算hash -&gt; 二次hash -&gt;二次hash的值与容量取模</p><ul><li><p>底层数据结构，1.7和1.8有什么不同？</p><ul><li>1.7数组+链表，1.8数组+（链表|红黑树）元素多的时候是红黑树，元素少的时候是链表</li></ul></li><li><p>为什么要用红黑树，为什么一上来不树化，树化阈值为什么是8，何时会被树化，何时会退化为链表？</p><ul><li><p>使用红黑树防止链表过长影响性能</p></li><li><p>树化条件：链表长度大于8，整个数组长度 &gt;= 64</p></li><li><p>链表短时没有必要进行树化，转化成树占用内存也会更多</p></li><li><p>正常情况下链表长度不会超过8</p></li><li><p>红黑树用来避免DoS攻击，防止链表超长性能下降，树化应当是偶然情况</p><ul><li><p>hash表的查找、更新的时间复杂度时O（1），而红黑树的查找、更新的复杂度是O（log2n），TreeNode重用空间也比普通Node大，如非必要，尽量使用链表</p></li><li><p>hash值如果足够随机，则再hash表内按泊松分布、再负载因子0.75情况下、长度超过8的概率是0.00000006，选择8就是为了让树化概率足够小</p></li></ul></li><li><p>退化的情况1：再扩容是如果拆分树是，树的元素个数&lt;=6就会退化成链表</p></li><li><p>退化的情况2：remove树节点时，若root、root.left、root.right、root.let.let有一个为null，也会退化为链表</p></li></ul></li><li><p>索引如何计算？hashCode都有了为何还要提供<code>hash()</code>方法？数组容量为何是2的n次幂</p><ul><li><p>求模运算优化 <code>97%16\`\` -&gt; 97&amp;(16-1)</code> 按位与 （必须是2的n次方否则不等价）</p></li><li><p>二次计算hash（扰动）是为了综合高位数据，让哈希分布更均匀，防止链表过长</p></li><li><p>1.8 二次hash代码：</p></li><li><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span><span class="token punctuation">(</span> h <span class="token operator">=</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul>`,17),t=[e];function p(o,c){return s(),l("div",null,t)}const d=a(i,[["render",p],["__file","集合.html.vue"]]);export{d as default};
