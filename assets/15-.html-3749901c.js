import{_ as n,X as s,Y as a,a2 as t}from"./framework-a8949fcd.js";const e={},p=t(`<h2 id="相关概念" tabindex="-1"><a class="header-anchor" href="#相关概念" aria-hidden="true">#</a> 相关概念</h2><ul><li>指针:一个变量在内存中包含的是一个地址(指向其他数据)</li><li>Rust中在常见的指针就是<strong>引用</strong></li><li>引用: <ul><li>使用符号<code>&amp;</code>表示</li><li>表示借用它指向的值</li><li>没有其余开销</li><li>最常见的指针类型</li></ul></li></ul><h3 id="智能指针" tabindex="-1"><a class="header-anchor" href="#智能指针" aria-hidden="true">#</a> 智能指针</h3><ul><li>智能指针是这样一些数据结构 <ul><li>行为和指针相似</li><li>有额外的元数据和功能</li></ul></li></ul><h3 id="引用计数-reference-counting-智能指针类型" tabindex="-1"><a class="header-anchor" href="#引用计数-reference-counting-智能指针类型" aria-hidden="true">#</a> 引用计数(reference counting)智能指针类型</h3><ul><li>通过记录所有者的数量,是一份数据被多个所有者同时持有</li><li>并在没有任何所有者时自动清理数据</li></ul><h3 id="引用和智能指针的其他不同" tabindex="-1"><a class="header-anchor" href="#引用和智能指针的其他不同" aria-hidden="true">#</a> 引用和智能指针的其他不同</h3><ul><li>引用:只借用数据</li><li>智能指针:很多时候都拥有它所指向的数据</li></ul><h3 id="智能指针的例子" tabindex="-1"><a class="header-anchor" href="#智能指针的例子" aria-hidden="true">#</a> 智能指针的例子</h3><ul><li><code>String</code>和<code>Vec&lt;T&gt;</code></li><li>它们都拥有一片内存区域,并且允许用户对其操作</li><li>还拥有元数据(例如容量等)</li><li>提供额外的功能或者保障(String保障其数据时合法的UTF-8编码)</li></ul><h3 id="智能指针的实现" tabindex="-1"><a class="header-anchor" href="#智能指针的实现" aria-hidden="true">#</a> 智能指针的实现</h3><ul><li>智能指针通常使用<code>Struct</code>实现,并且实现了: <ul><li><code>Deref</code>和<code>Drop</code>这两个trait</li></ul></li><li><code>Deref trait</code>:允许智能指针struct的实例像引用一样使用</li><li><code>Drop trait</code>:允许你自定义当智能指针实例走出作用域时的代码</li></ul><h3 id="标准库常见的智能指针" tabindex="-1"><a class="header-anchor" href="#标准库常见的智能指针" aria-hidden="true">#</a> 标准库常见的智能指针</h3><ul><li><code>Box&lt;T&gt;</code>:在heap内存上分配值</li><li><code>Rc&lt;T&gt;</code>:启用多重所有权的引用计数类型</li><li><code>Ref&lt;T&gt;</code>和<code>RefMut&lt;T&gt;</code>:通过<code>RefCell&lt;T&gt;</code>访问:在运行时而不是编译时强制借用规则的类型</li></ul><h2 id="_15-1-使用-box-t-来指向heap上的数据" tabindex="-1"><a class="header-anchor" href="#_15-1-使用-box-t-来指向heap上的数据" aria-hidden="true">#</a> 15.1 使用 <code>Box&lt;T&gt;</code>来指向Heap上的数据</h2><h3 id="box-t" tabindex="-1"><a class="header-anchor" href="#box-t" aria-hidden="true">#</a> <code>Box&lt;T&gt;</code></h3><ul><li><code>Box</code>是一种最简单的智能指针: <ul><li>允许你在heap上存储数据而不是stack</li><li>stack上是指向heap数据的指针</li><li>没有其他性能开销</li><li>没有其他额外的功能</li><li>实现了Dref trait 和 Drop trait</li></ul></li></ul><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h3><ul><li>在编译时,某些类型的大小无法确定,但使用该类型时,上下文却需要知道它确切的大小</li><li>当你有大量数据,想要移交所有权,但需要确保在操作时数据不会被复制</li><li>使用某个值时,你只关心它是否实现了特定的trait,而不关心它的具体类型</li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">mian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{b}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 走出作用域时会自动释放存放在stack上的指针和heap上的值</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用box赋能递归类型" tabindex="-1"><a class="header-anchor" href="#使用box赋能递归类型" aria-hidden="true">#</a> 使用Box赋能递归类型</h3><ul><li>在编译时,Rust需要知道一个类型所占的空间大小</li><li>而递归类型的大小无法在编译时确定</li><li>但是Box类型的大小确定</li><li>函数式语言中的Cons List</li></ul><h3 id="关于cons-list" tabindex="-1"><a class="header-anchor" href="#关于cons-list" aria-hidden="true">#</a> 关于Cons List</h3><ul><li>Cons List是来自Lisp语言的一种数据结构</li><li>Cons List里每个成员由两个元素组成 <ul><li>当前项的值</li><li>下一个元素</li></ul></li><li>Cons List里最后一个成员只包含一个Nil值(相当于中止标记),不包含下一个元素</li><li>相当于一种链表</li></ul><h3 id="cons-list-并不是rust的常用集合" tabindex="-1"><a class="header-anchor" href="#cons-list-并不是rust的常用集合" aria-hidden="true">#</a> Cons List 并不是Rust的常用集合</h3><ul><li>通常情况下,<code>Vec&lt;T&gt;</code>是更好的选择</li><li>Rust如何确定为枚举分配的空间大小 <ul><li>遍历枚举中的每一个变体,找出需要最大空间的变体</li></ul></li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">Message</span> <span class="token punctuation">{</span>
  <span class="token class-name">Quit</span><span class="token punctuation">,</span>
  <span class="token class-name">Move</span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span>y<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token class-name">Write</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token class-name">ChangeColor</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span><span class="token keyword">i32</span><span class="token punctuation">,</span><span class="token keyword">i32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用box来获得确定大小的递归类型" tabindex="-1"><a class="header-anchor" href="#使用box来获得确定大小的递归类型" aria-hidden="true">#</a> 使用Box来获得确定大小的递归类型</h3><ul><li><code>Box&lt;T&gt;</code>是一个指针,Rust知道它需要多少空间,因为: <ul><li>指针的大小不会因为所指向的数据的大小变化而变化</li></ul></li><li><code>Box&lt;T&gt;</code><ul><li>只提供了&quot;间接&quot;存储和heap内存分配的功能</li><li>没有其他额外功能</li><li>没有性能开销</li><li>适用于需要&quot;间接&quot;存储的场景,例如Cons List</li><li>实现了<code>Deref trait</code>和<code>Drop trait</code></li></ul></li></ul><h2 id="_15-2-deref-trait" tabindex="-1"><a class="header-anchor" href="#_15-2-deref-trait" aria-hidden="true">#</a> 15.2 Deref trait</h2><h3 id="deref-trait" tabindex="-1"><a class="header-anchor" href="#deref-trait" aria-hidden="true">#</a> Deref Trait</h3><ul><li>实现Deref Trait使我们可以<strong>自定义解引用运算符<code>*</code>的行为</strong></li><li>通过Deref,智能指针可以像<strong>常规引用一样来处理</strong></li></ul><h3 id="解引用运算符" tabindex="-1"><a class="header-anchor" href="#解引用运算符" aria-hidden="true">#</a> 解引用运算符</h3><ul><li>常规引用也是一种指针</li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>

    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="把box-t-当作引用" tabindex="-1"><a class="header-anchor" href="#把box-t-当作引用" aria-hidden="true">#</a> 把<code>Box&lt;T&gt;</code>当作引用</h3><ul><li><code>Box&lt;T&gt;</code>可以代替上例的引用</li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token class-name">Box</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="定义自己的智能指针" tabindex="-1"><a class="header-anchor" href="#定义自己的智能指针" aria-hidden="true">#</a> 定义自己的智能指针</h3><ul><li><code>Box&lt;T&gt;</code>被定义成拥有一个元素的tuple struct</li><li>(例子)<code>MyBox&lt;T&gt;</code></li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">Deref</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 相当于一个有名称的元组</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token type-definition class-name">Target</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">;</span> <span class="token comment">// 定义了deref的关联类型</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// let y = Box::new(x);</span>

    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Rust会隐式的把\`*y\`展开为\`*(y.deref())\`</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实现deref-trait" tabindex="-1"><a class="header-anchor" href="#实现deref-trait" aria-hidden="true">#</a> 实现Deref Trait</h3><ul><li>标准库中的Deref trait要求我们实现一个deref方法 <ul><li>该方法借用self</li><li>返回一个指向内部数据的引用</li></ul></li></ul><h2 id="_15-2-deref-trait-2" tabindex="-1"><a class="header-anchor" href="#_15-2-deref-trait-2" aria-hidden="true">#</a> 15.2 Deref Trait(2)</h2><h3 id="函数和方法的隐式解引用转化-deref-coercion" tabindex="-1"><a class="header-anchor" href="#函数和方法的隐式解引用转化-deref-coercion" aria-hidden="true">#</a> 函数和方法的隐式解引用转化(Deref Coercion)</h3><ul><li>为函数和方法提供的一种便捷特性</li><li>假设T实现了Deref trait <ul><li>Deref Coercion可以把T的引用转化为T经过Deref操作后生成的引用</li></ul></li><li>当把某类型的引用传递给函数或方法时,但它的类型与定义的参数类型不匹配 <ul><li>Deref Coercion就会自动化发生</li><li>编译器会对deref进行一系列调用,来把它转化为所需的参数类型 <ul><li>在编译时完成,没有额外的性能开销</li></ul></li></ul></li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span></span><span class="token class-name">Deref</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token type-definition class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 相当于一个有名称的元组</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token class-name">Deref</span> <span class="token keyword">for</span> <span class="token class-name">MyBox</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> <span class="token type-definition class-name">Target</span> <span class="token operator">=</span> <span class="token class-name">T</span><span class="token punctuation">;</span> <span class="token comment">// 定义了deref的关联类型</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token class-name">T</span> <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{name}&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">MyBox</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;zyf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// &amp;m &amp;MyBox&lt;String&gt;</span>
    <span class="token comment">// deref &amp;String</span>
    <span class="token comment">// deref &amp;str</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="解引用与可变性" tabindex="-1"><a class="header-anchor" href="#解引用与可变性" aria-hidden="true">#</a> 解引用与可变性</h3><ul><li>可使用DerefMut trait重载可变引用的*运算符</li><li>在类型和trait在下列三种情况发生时,Rust会执行deref coercion: <ul><li>当T:<code>Deref&lt;Target=U&gt;</code>,允许&amp;T转化为&amp;U</li><li>当T:<code>DerefMut&lt;Target=U&gt;</code>,允许&amp;mut T转化为&amp;mut U</li><li>当T:<code>Deref&lt;Target=U&gt;</code>,允许&amp;mut T转化为&amp;U</li></ul></li></ul><h2 id="_15-3-drop-trait" tabindex="-1"><a class="header-anchor" href="#_15-3-drop-trait" aria-hidden="true">#</a> 15.3 Drop Trait</h2><h3 id="drop-trait" tabindex="-1"><a class="header-anchor" href="#drop-trait" aria-hidden="true">#</a> Drop Trait</h3><ul><li>实现Drop Trait,可以让我们自定义<strong>当值将要离开作用域时发生的动作</strong><ul><li>例如:文件或者网络资源释放</li><li>任何类型都可以实现Drop trait</li></ul></li><li>Drop trait 只要求实现drop方法 <ul><li>参数:对self的可变引用</li></ul></li><li>Drop trait在预导入模块里(prelude)</li></ul><h3 id="使用std-mem-drop来提前drop值" tabindex="-1"><a class="header-anchor" href="#使用std-mem-drop来提前drop值" aria-hidden="true">#</a> 使用std::mem::drop来提前drop值</h3><ul><li>很难直接禁用自动的drop值,也没有必要 <ul><li>drop trait的目的就是进行自动的释放处理逻辑</li></ul></li><li>Rust不允许手动调用drop trait的drop方法</li><li>可以调用<code>std::mem::drop</code>函数,来提前drop值(在预导入模块)</li></ul><h2 id="_15-4-rc-t-引用计数智能指针" tabindex="-1"><a class="header-anchor" href="#_15-4-rc-t-引用计数智能指针" aria-hidden="true">#</a> 15.4 <code>Rc&lt;T&gt;</code>引用计数智能指针</h2><h3 id="rc-t-引用计数智能指针" tabindex="-1"><a class="header-anchor" href="#rc-t-引用计数智能指针" aria-hidden="true">#</a> <code>Rc&lt;T&gt;</code>引用计数智能指针</h3><ul><li>有时一个值会有多个所有者</li><li>为了支持多重所有权Rust提供了:<code>Rc&lt;T&gt;</code><ul><li>reference counting(引用计数)</li><li>追踪所有到值的引用</li><li>0个引用:该值可以被清理</li></ul></li></ul><h3 id="rc-t-使用场景" tabindex="-1"><a class="header-anchor" href="#rc-t-使用场景" aria-hidden="true">#</a> <code>Rc&lt;T&gt;</code>使用场景</h3><ul><li>需要在heap上分配数据,这些数据被程序的多个部分读取(只读),但在编译时无法确定哪个部分最后使用完这些数据</li><li><code>Rc&lt;T&gt;</code>只能用于单线程场景</li></ul><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h3><ul><li><code>Rc&lt;T&gt;</code><strong>不在</strong>预导入模块(prelude)</li><li><code>Rc::clone(&amp;a)</code>函数:增加引用计数</li><li><code>Rc::Strong_count(&amp;a)</code>:获得引用计数 <ul><li>还有<code>Rc::weak_count</code>函数</li></ul></li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">{</span>
    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token keyword">i32</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">List</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Nil</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">::</span><span class="token class-name">List</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Cons</span><span class="token punctuation">,</span> <span class="token class-name">Nil</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="rc-clone-对比类型的clone-方法" tabindex="-1"><a class="header-anchor" href="#rc-clone-对比类型的clone-方法" aria-hidden="true">#</a> <code>Rc::clone()</code>对比类型的<code>clone()</code>方法</h3><ul><li>Rc::clone():增加引用,不会执行数据的深度拷贝操作</li><li>类型的clone():很多都会执行数据的深度拷贝操作</li></ul><h3 id="rc-t" tabindex="-1"><a class="header-anchor" href="#rc-t" aria-hidden="true">#</a> <code>Rc&lt;T&gt;</code></h3><ul><li><code>Rc&lt;T&gt;</code>通过<strong>不可变引用</strong>,使你可以在程序不同部分之间共享<strong>只读</strong>数据</li></ul><h2 id="_15-5-refcell-t-和内部可变性" tabindex="-1"><a class="header-anchor" href="#_15-5-refcell-t-和内部可变性" aria-hidden="true">#</a> 15.5 <code>RefCell&lt;T&gt;</code>和内部可变性</h2><h3 id="内部可变性-interior-mutability" tabindex="-1"><a class="header-anchor" href="#内部可变性-interior-mutability" aria-hidden="true">#</a> 内部可变性(interior mutability)</h3><ul><li>内部可变性是Rust的设计模式之一</li><li>它允许你在只持有不可变引用的前提下对数据进行修改 <ul><li>数据结构中使用了unsafe代码来绕过Rust正常的可变性和借用规则</li></ul></li></ul><h3 id="refcell-t" tabindex="-1"><a class="header-anchor" href="#refcell-t" aria-hidden="true">#</a> <code>RefCell&lt;T&gt;</code></h3><ul><li>与<code>Rc&lt;T&gt;</code>不同,<code>RefCell&lt;T&gt;</code>类型代表了其持有数据的唯一所有权</li><li>与<code>Rc&lt;T&gt;</code>相似,只能用于<strong>单线程</strong>场景</li></ul><div class="hint-container tip"><p class="hint-container-title">回忆借用规则</p><p>在任何给定的时间里,你要么只能拥有一个可变引用,要么只能拥有任意数量的不可变引用</p><p>引用总是有效的</p></div><h3 id="refcell-t-和box-t-的区别" tabindex="-1"><a class="header-anchor" href="#refcell-t-和box-t-的区别" aria-hidden="true">#</a> <code>RefCell&lt;T&gt;</code>和<code>Box&lt;T&gt;</code>的区别</h3><table><thead><tr><th><code>Box&lt;T&gt;</code></th><th><code>RefCell&lt;T&gt;</code></th></tr></thead><tbody><tr><td><strong>编译阶段</strong>强制代码遵守借用规则,否则会出现错误</td><td>只会在<strong>运行时</strong>检查借用规则,否则触发panic!</td></tr></tbody></table><table><thead><tr><th>编译阶段</th><th>运行时</th></tr></thead><tbody><tr><td>尽早暴露问题</td><td>问题暴露延后,甚至到生产环境</td></tr><tr><td>没有运行时开销</td><td>因借用计数产生些许性能损失</td></tr><tr><td>对大多数场景是最佳选择</td><td>实现某些特定的内存安全场景(不可变环境中修改自身数据)</td></tr><tr><td>是Rust的默认行为</td><td></td></tr></tbody></table><h3 id="选择box-t-rc-t-refcell-t-的依据" tabindex="-1"><a class="header-anchor" href="#选择box-t-rc-t-refcell-t-的依据" aria-hidden="true">#</a> 选择<code>Box&lt;T&gt;</code> <code>Rc&lt;T&gt;</code> <code>RefCell&lt;T&gt;</code>的依据</h3><table><thead><tr><th></th><th><code>Box&lt;T&gt;</code></th><th><code>Rc&lt;T&gt;</code></th><th><code>RefCell&lt;T&gt;</code></th></tr></thead><tbody><tr><td>同一数据的所有者</td><td>一个</td><td>多个</td><td>一个</td></tr><tr><td>可变性</td><td>可变及不可变借用</td><td>不可变借用</td><td>可变及不可变借用</td></tr><tr><td>借用检查</td><td>编译时检查</td><td>编译时检查</td><td>运行时检查</td></tr></tbody></table><h3 id="内部可变性-可变的借用一个不可变的值" tabindex="-1"><a class="header-anchor" href="#内部可变性-可变的借用一个不可变的值" aria-hidden="true">#</a> 内部可变性:可变的借用一个不可变的值</h3><h3 id="使用refcell-t-在运行时记录借用信息" tabindex="-1"><a class="header-anchor" href="#使用refcell-t-在运行时记录借用信息" aria-hidden="true">#</a> 使用<code>RefCell&lt;T&gt;</code>在运行时记录借用信息</h3><ul><li><p>两个方法（安全接口）</p><ul><li>borrow方法 <ul><li>返回智能指针<code>Ref&lt;T&gt;</code>，它实现了Deref</li></ul></li><li>borrow_mut方法 <ul><li>返回智能指针<code>RefMut&lt;T&gt;</code>,它实现了Dref</li></ul></li></ul></li><li><p><code>RefCell&lt;T&gt;</code>会记录当前存在多少个活跃的<code>Ref&lt;T&gt;</code>和<code>RefMut&lt;T&gt;</code>智能指针</p><ul><li>每次调用borrow：不可变借用计数加1</li><li>任何一个<code>Ref&lt;T&gt;</code>的值离开作用域被释放时：不可变借用计数减1</li><li>每次调用borrow_mut：可变借用计数加1</li><li>任何一个<code>RefMut&lt;T&gt;</code>的值离开作用域被释放时：可变借用计数减1</li></ul></li><li><p>以此计数来维护借用检查规则</p><ul><li>在任何一个给定的时间里，只允许拥有多个不可变借用或一个可变借用</li></ul></li></ul><h3 id="将rc-t-和refcell-t-结合使用来实现一个拥有多重所有权的可变数据" tabindex="-1"><a class="header-anchor" href="#将rc-t-和refcell-t-结合使用来实现一个拥有多重所有权的可变数据" aria-hidden="true">#</a> 将<code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>结合使用来实现一个拥有多重所有权的可变数据</h3><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">enum</span> <span class="token type-definition class-name">List</span> <span class="token punctuation">{</span>
    <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">RefCell</span><span class="token operator">&lt;</span><span class="token keyword">i32</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Rc</span><span class="token operator">&lt;</span><span class="token class-name">List</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Nil</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">use</span> <span class="token keyword">crate</span><span class="token punctuation">::</span><span class="token class-name">List</span><span class="token punctuation">::</span><span class="token punctuation">{</span><span class="token class-name">Cons</span><span class="token punctuation">,</span> <span class="token class-name">Nil</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>rc<span class="token punctuation">::</span></span><span class="token class-name">Rc</span><span class="token punctuation">;</span>
<span class="token keyword">use</span> <span class="token namespace">std<span class="token punctuation">::</span>cell<span class="token punctuation">::</span></span><span class="token class-name">RefCell</span><span class="token punctuation">;</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">Nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token class-name">Cons</span><span class="token punctuation">(</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">RefCell</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Rc</span><span class="token punctuation">::</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">*</span>value<span class="token punctuation">.</span><span class="token function">borrow_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:?}&quot;</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="其他可实现内部可变性的类型" tabindex="-1"><a class="header-anchor" href="#其他可实现内部可变性的类型" aria-hidden="true">#</a> 其他可实现内部可变性的类型</h3><ul><li><code>Cell&lt;T&gt;</code>：通过复制来访问数据</li><li><code>Mutex&lt;T&gt;</code>:用于实现跨线程情形下的内部可变性模式</li></ul><h2 id="_15-6-循环引用可导致内存泄漏" tabindex="-1"><a class="header-anchor" href="#_15-6-循环引用可导致内存泄漏" aria-hidden="true">#</a> 15.6 循环引用可导致内存泄漏</h2><h3 id="rust可能发生内存泄漏" tabindex="-1"><a class="header-anchor" href="#rust可能发生内存泄漏" aria-hidden="true">#</a> Rust可能发生内存泄漏</h3><ul><li>例如使用<code>Rc&lt;T&gt;</code>和<code>RefCell&lt;T&gt;</code>就可能创造出循环引用，从而发生内存泄漏 <ul><li>每个项的引用数量不会变成0，值也不会被处理掉</li></ul></li></ul>`,87),l=[p];function o(c,i){return s(),a("div",null,l)}const r=n(e,[["render",o],["__file","15-.html.vue"]]);export{r as default};
