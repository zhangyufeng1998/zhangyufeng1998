import{_ as a,X as l,Y as e,a2 as i}from"./framework-a8949fcd.js";const s={},n=i(`<h2 id="_11-1-编写和运行测试" tabindex="-1"><a class="header-anchor" href="#_11-1-编写和运行测试" aria-hidden="true">#</a> 11.1 编写和运行测试</h2><h3 id="测试-函数" tabindex="-1"><a class="header-anchor" href="#测试-函数" aria-hidden="true">#</a> 测试（函数）</h3><ul><li>测试 <ul><li>函数</li><li>验证非测试代码的功能是否和预期一致</li></ul></li><li>测试函数体（通常）执行的三个操作 <ul><li>准备数据、状态</li><li>运行被测试的代码</li><li>断言（Assert）结果</li></ul></li></ul><h3 id="解剖测试函数" tabindex="-1"><a class="header-anchor" href="#解剖测试函数" aria-hidden="true">#</a> 解剖测试函数</h3><ul><li>测试函数需要使用test属性（attribute）进行标注 <ul><li>Attribute就是一段Rust代码的元数据</li><li>在函数上加上#[test]可以把函数变成测试函数</li></ul></li></ul><h3 id="运行测试" tabindex="-1"><a class="header-anchor" href="#运行测试" aria-hidden="true">#</a> 运行测试</h3><ul><li>使用<code>cargo test</code>命令运行所有的测试函数 <ul><li>Rust会构建一个Test Runner可执行文件 <ul><li>它会运行标注了test的函数，并报告其运行是否成功</li></ul></li></ul></li><li>使用cargo创建library项目的时候，会生成一个test module，里面有一个test函数 <ul><li>可以在项目里添加任意数量的test module或函数</li></ul></li></ul><h3 id="测试失败" tabindex="-1"><a class="header-anchor" href="#测试失败" aria-hidden="true">#</a> 测试失败</h3><ul><li>测试函数panic就表示失败</li><li>每个测试运行在一个新的线程</li><li>当主线程看见某个测试线程挂掉了，那个测试就标记为失败</li></ul><h2 id="_11-2-断言-assert" tabindex="-1"><a class="header-anchor" href="#_11-2-断言-assert" aria-hidden="true">#</a> 11.2 断言（Assert）</h2><h3 id="使用assert-宏检查测试结果" tabindex="-1"><a class="header-anchor" href="#使用assert-宏检查测试结果" aria-hidden="true">#</a> 使用assert!宏检查测试结果</h3><ul><li>assert!宏，来自标准库，用来确定某个状态是否为true <ul><li>true：测试通过</li><li>false：调用panic!</li></ul></li></ul><h3 id="使用assert-eq-和assert-ne-测试相等性" tabindex="-1"><a class="header-anchor" href="#使用assert-eq-和assert-ne-测试相等性" aria-hidden="true">#</a> 使用assert_eq!和assert_ne!测试相等性</h3><ul><li>来自标准库</li><li>判断两个参数是否相等</li><li>实际上使用的就是 <code>==</code>和 <code>!=</code></li><li>断言失败：自动打出两个参数的值 <ul><li>使用debug格式打印参数 <ul><li>要求参数实现了partialEq和Debug trait（所有的基本类型和标准库里大部分函数都实现了）</li></ul></li></ul></li></ul><div class="language-rust line-numbers-mode" data-ext="rs"><pre class="language-rust"><code><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">add_two</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token attribute attr-name">#[cfg(test)]</span>
<span class="token keyword">mod</span> <span class="token module-declaration namespace">tests</span> <span class="token punctuation">{</span>
    <span class="token keyword">use</span> <span class="token keyword">super</span><span class="token punctuation">::</span><span class="token operator">*</span><span class="token punctuation">;</span>

    <span class="token attribute attr-name">#[test]</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">it_adds_two</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token function">add_two</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_11-3-自定义错误信息" tabindex="-1"><a class="header-anchor" href="#_11-3-自定义错误信息" aria-hidden="true">#</a> 11.3 自定义错误信息</h2><h3 id="添加自定义错误消息" tabindex="-1"><a class="header-anchor" href="#添加自定义错误消息" aria-hidden="true">#</a> 添加自定义错误消息</h3><ul><li>可以向assert!、assert_wq!、assert_ne!添加可选的自定义消息 <ul><li>这些自定义消息和失败消息都会打印出来</li><li>assert!:第一个参数必填，自定义消息作为第二个参数</li><li>assert_eq!、assert_ne!：前两个参数必填，自定义消息作为第三个参数</li><li>自定义消息参数会被传递给format!宏，可以使用{}占位符</li></ul></li></ul><h2 id="_11-4-用should-panic检查恐慌" tabindex="-1"><a class="header-anchor" href="#_11-4-用should-panic检查恐慌" aria-hidden="true">#</a> 11.4 用should_panic检查恐慌</h2><p><code>#[should_panic]</code></p><h2 id="_11-5-在测试中使用result-t-e" tabindex="-1"><a class="header-anchor" href="#_11-5-在测试中使用result-t-e" aria-hidden="true">#</a> 11.5 在测试中使用<code>Result&lt;T,E&gt;</code></h2><ul><li>无需panic，可以使用Result作为返回类型编写测试 <ul><li>返回Ok，测试通过</li><li>返回Err，测试失败</li></ul></li><li><strong>注意</strong>不用使用Result编写的测试上面标注<code>#[should_panic]</code></li></ul><h2 id="_11-6-控制测试如何运行" tabindex="-1"><a class="header-anchor" href="#_11-6-控制测试如何运行" aria-hidden="true">#</a> 11.6 控制测试如何运行</h2><ul><li>改变cargo test的行为：添加命令行参数</li><li>默认行为： <ul><li>并行运行</li><li>所有测试</li><li>捕获（不显示）所有输出，使读取与测试结果相关的输出更容易</li></ul></li><li>命令行参数 <ul><li>针对cargo test的参数：紧跟cargo test后</li><li>针对测试可执行程序：放在 -- 之后</li></ul></li><li>cargo test --help</li><li>cargo test -- --help</li></ul><h3 id="并行运行测试" tabindex="-1"><a class="header-anchor" href="#并行运行测试" aria-hidden="true">#</a> 并行运行测试</h3><ul><li>运行多个测试：默认使用多个线程并行运行 <ul><li>运行快</li></ul></li><li>测试之间： <ul><li>不会相互依赖</li><li>不依赖于某个共享状态</li></ul></li></ul><h3 id="test-threads参数" tabindex="-1"><a class="header-anchor" href="#test-threads参数" aria-hidden="true">#</a> --test-threads参数</h3><ul><li>传递给二进制文件</li><li>不想以并行的方式运行测试，或对线程数进行细颗粒度控制</li><li>可以使用 --test-threads参数，后面跟着线程的数量</li><li>例如：cargo test -- --test-threads=1</li></ul><h3 id="显式函数输出" tabindex="-1"><a class="header-anchor" href="#显式函数输出" aria-hidden="true">#</a> 显式函数输出</h3><ul><li>默认，如果测试通过，Rust的test库会捕获所有打印到标准输出的内容</li><li>例如如果被测试代码中用到了println!： <ul><li>如果测试通过：不会在终端看到println!打印的内容</li><li>如果测试失败：就会看到println!打印的内容和失败信息</li></ul></li><li>如果想在成功的测试中看到打印的内容： --show-output</li></ul><h2 id="_11-7-按测试的名称运行测试" tabindex="-1"><a class="header-anchor" href="#_11-7-按测试的名称运行测试" aria-hidden="true">#</a> 11.7 按测试的名称运行测试</h2><ul><li>将测试的名称作为cargo test的参数</li><li>运行单个测试：指定测试名</li><li>运行多个测试：指定测试名的一部分 （模块名也可以）</li></ul><h2 id="_11-8-忽略测试" tabindex="-1"><a class="header-anchor" href="#_11-8-忽略测试" aria-hidden="true">#</a> 11.8 忽略测试</h2><ul><li>ignore属性（attribute）</li><li>运行被忽略的测试 <ul><li>cargo -test -- --ignored</li></ul></li></ul><h2 id="_11-9-测试的组织" tabindex="-1"><a class="header-anchor" href="#_11-9-测试的组织" aria-hidden="true">#</a> 11.9 测试的组织</h2><ul><li>Rust 测试分类 <ul><li>单元测试</li><li>集成测试</li></ul></li><li>单元测试 <ul><li>小、专注</li><li>一次对一个模块进行隔离的测试</li><li>可以测试private接口</li></ul></li><li>集成测试 <ul><li>在库外部。和其他代码一样 使用你的代码</li><li>只能访问public接口</li><li>可能在测试的时候用到多个模块</li></ul></li></ul><h3 id="单元测试" tabindex="-1"><a class="header-anchor" href="#单元测试" aria-hidden="true">#</a> 单元测试</h3><h4 id="cfg-test-标注" tabindex="-1"><a class="header-anchor" href="#cfg-test-标注" aria-hidden="true">#</a> #[cfg(test)]标注</h4><ul><li>tests模块上的#[cfg(test)]标注 <ul><li>只有运行cargo test才会编译和运行代码</li><li>运行cargo build则不会</li></ul></li><li>集成测试在不同的目录，不需要#[cfg(test)]标注</li><li>cfg：configuration（配置） <ul><li>告诉Rust下面的条目，只有在指定的配置选项下才被包含</li><li>配置选项test：由Rust提供，用来编译和运行测试。 <ul><li>只有cargo test才会编译代码，包括模块中的helper函数和#[test]标注的函数</li></ul></li></ul></li></ul><h3 id="集成测试" tabindex="-1"><a class="header-anchor" href="#集成测试" aria-hidden="true">#</a> 集成测试</h3><ul><li>验证被测试库的多个部分是否能正确地一起工作</li></ul><h4 id="tests目录" tabindex="-1"><a class="header-anchor" href="#tests目录" aria-hidden="true">#</a> tests目录</h4><p><code>pass</code></p>`,43),t=[n];function r(u,d){return l(),e("div",null,t)}const o=a(s,[["render",r],["__file","11-.html.vue"]]);export{o as default};
